## section 1

- Next.js 쓰는 이유:

  - 풀스택 앱을 구축 가능 (리액트로 풀스택 애플리케이션을 구축하는 과정을 단순화한다.)
  - Nest.js 는 form 처리, 데이터 fertching, 사용자 인증 등을 제공한다.
  - 파일 시스템을 사용하여 경로 설정이 가능 (React 에서 Router 를 사용하는것처럼 코드를 사용하여 설정하는 대신, 파일 시스템으로 경로가 자동 설정 된다.)
  - spa와는 달리 페이지에 보이는 모든 내용을 렌더링 하기 때문에, 검색 엔진 크롤러에서 다 노출이 가능하다.

- App Router vs Pages Router:
  - Pages Router 는 13버전 이전까지의 방식. 비교적 안정적.
  - App Router 는 13버전부터 소개된 방식. 리액트 서버 컴포넌트나 server actions와 같은 다양한 최신기능 사용할 수 있다.

## section 3

- Next.js 핵심(앱라우터)

파일구조가 이렇게 되어있으면 path 는 이런식으로 된다.

```jsx
app / layout.js; // 루트 레이아웃
page.js; // 홈페이지
about / page.js; // /about 페이지
blog /
  [slug] / // 동적 라우트
  page.js(
    // /blog/[slug] 페이지
    marketing
  ) / // 라우트 그룹
  about /
  page.js;
```

- 라우트 그룹: (폴더명) 이렇게 표시한다.
  - (폴더명) 을 사용해서 라우트를 그룹화한다.
  - URL 구조에는 영향 주지 않음.
  - 같은 레이아웃을 공유하는 페이지들을 구성할때 유용하다.
- 병렬 라우트:
  - @folder 문법을 사용하여 동시에 여러 페이지를 렌더링
  - 대시보드나 모달과 같은 복잡한 UI 패턴 구현 가능
  ```jsx
  // 이런구조 참고하기
  app/
    @modal/
      login/
        page.js
    @sidebar/
      settings/
        page.js
    layout.js
    page.js
  ```
- 서버 컴포넌트

  - 기본적으로 모든 컴포넌트는 서버 컴포넌트로 동작한다.
  - 'use client' 를 붙이면 클라이언트 컴포넌트로 전환됨
  - 데이터 페칭, DB 접근 등을 서버에서 직접 수행 가능

- app 디렉토리 하위의 page.js 는 next.js 에게 페이지를 렌더링 해야한다고 말해주는것. app 디렉토리 내에서 폴더로 라우트 구조를 정의할수 있다.
- 특정 폴더 안의 page.js 는 해당 라우트의 UI를 표시하는 페이지 컴포넌트.

- 이 page.js 를 보면 일반적인 react 의 컴포넌트와 같은 형식이다. react 의 컴포넌트와 다를게 없어보이지만, next.js 는 이 컴포넌트가 서버에 렌더링 되고, 컴포넌트 함수가 서버에 실행되는것을 보장한다.

- app 라우터의 기본값은 서버컴포넌트이기 때문에 console.log를 기본 컴포넌트에 찍어봐도 로그가 보이지 않고 터미널에서만 보인다. (크롬에서는 보인다. 왼쪽에 server 라고 표시뜨고, 터미널에서도 확인할수 있고, 크롬 개발자 도구에서도 확인가능.)

- 앱라우터의 path 가 되는 폴더이름의 page.js 안에는 컴포넌트를 export 하는데, 이름은 아무 이름이나 해줘된다. 원하는 이름으로.(최상위 app - page.js 에 Home 이라는 컴포넌트 이름을 쓰는것 처럼)

- 페이지 이동하는 링크(Link 태그)

  - a(앵커) 태그를 사용하면, 페이지가 지속적으로 리로딩 된다.
  - a 태그 대신 Link 태그를 사용하여, 계속 리로딩이 되는것을 막아준다.
    다음 페이지의 내용이 서버에 렌더링 되고, 클라이언트로 보내져, 클라이언트 사이드 자바스크립트 코드가 처리해서 화면에 보이는 것을 업데이트 해주는 방식이다.

- 레이아웃(layout.ts)
  - 모든 Next.js 프로젝트에는 최소 하나의 layout.js 파일이 필요
  - 중첩된 layout.js 파일이 있을수도있다. 폴더 안에 있는 layout 파일.
  - layout.js 에 기본으로 셋팅을 하면, metadata 가 정의 되어 있을것이다. 이 레이아웃에 포함된 모든 페이지에 적용된다.
    이 변수 metadata 는 정해진 이름이다.(바꾸지 않는다.)
    이렇게 정의한것은 이 특정 레이아웃에 포함된 모든 페이지에 적용된다.
    app 디렉터리의 layout.js 를 확인해보면, jsx 구문에 html, body 등이 있는데,
    head 부분이 없는 이유는, head 에 들어가는 모든 내용은 메타데이터에 의해 설정되거나, next.js 로 인해 자동으로 설정되기 때문이다.
- globals.css
  - layout.js 에 import 된다.(모든 페이지에서 사용가능)
- icon.png
  - favicon 으로 사용된다. (icon이라는 이름으로 넣어주면 favicon으로 적용된다.)
- components 폴더
  - 는 app 폴더 외부에 저장하는것을 선호한다.
  - 그렇게하면, app 폴더를 라우팅과 그와 관련된 일에만 사용할 수 있기 때문.
- @ : 앳 사인.
  - app 폴더 외부에있는 root 프로젝트를 의미한다.
  - import 경로를 단순화 할 수 있다.
- not-found.js => ‘Not Found’ 오류에 대한 폴백 페이지(형제 또는 중첩 페이지 또는 레이아웃에서 전달된)

error.js => 기타 오류에 대한 폴백 페이지(형제 또는 중첩 페이지 또는 레이아웃에서 전달된)

loading.js => 형제 또는 중첩 페이지(또는 레이아웃)가 데이터를 가져오는 동안 표시되는 폴백 페이지

- 동적라우팅 : 예를 들어, posts 라는 블로그 목록이 있고 포스트 목록을 클릭시, 각각의 post 페이지로 이동을 해야할때,
  posts/1, posts/2 등의 이름으로 이동을 하고싶을때, 1, 2 이렇게 바뀌는 이름을 동적으로 바꿔주려면, [id] 이런식의 대괄호로 감싸서 동적라우팅을 생성할 수 있다.
  코드를 예로 들면, moonlog의
- posts - page.tsx - [id] - page.tsx
  이런식으로 작성된 코드에서, posts에서 이렇게
  {posts.map((post) => (
  <Link
  href={{ pathname: `/posts/${post.id}` }}
  key={post.id}
  className="block group" >))}
  Link 태그로 동적인 pathname을 주면서 이 post.id 를 param 으로 전달해줄 수 있다.
  이런경우에, [id] - page.tsx 파일에서는, params 를 prop 으로 전달받을 수 있는데,
  params.id 를 하면, 이동적 경로인 엔드포인트를 얻을 수 있다. [] 대괄호 안에 써있는 문자가 abc 라면,
  params.abc 이런식으로 얻을 수 있다.
