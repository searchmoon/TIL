알고리즘 문제해결 전략 1


# 2장. 
2.3 문제해결전략(39쪽부터)
순서를 강제하는 기법의 연장선인 정규화.
- 정규화: 형태는 다르지만 결과적으로는 똑같은 것들을 그룹으로 묶은 뒤, 각 그릅들의 대표들만을 고려하는 방법.

# 3장. 코딩과 디버깅에 관하여
 ### 3.1 코딩의 중요성
 - 읽기 쉬운 코드 작성하기
 ### 3.2 좋은 코드를 짜기 위한 원칙
 - 간결한 코드를 작성하기
 - 적극적으로 코드 재사용하기
    - 코드 모듈화 하기. 같은 코드 세번 이상 등장 시, 해당 코드 함수로 분리해서 재사용하기
 - 표준 라이브러리 공부하기
 - 항상 같은 형태로 프로그램 작성하기
    - 자주 작성하는 알고리즘이나 코드 등의 일관성 지키기
 - 일관적이고 명료한 명명법 사용하기
    - 모호하지 않은 변수명, 함수명 사용하기
 - 모든 자료를 정규화해서 저장하기
    - 같은 자료를 두가지 형태로 저장하지 않기
 - 코드와 데이터를 분리하기

### 3.3 자주 하는 실수
 - 산술 오버플로: 계산 과정에서 변수의 표현범위를 벗어나는 값을 사용하는것
 - 배열 범위 밖 원소에 접근
 - 일관되지 않은 범위 표현 방식 사용하기
    - 한가지 방법으로 범위 표현 방식 따르기
 - Off-by-one 오류: 계산의 큰 줄기는 맞지만 하나가 모자라거나, 하나가 많아서 틀리는 코드의 오류
    - 최소 입력이 주어졌을때 이 코드가 어떻게 동작할지 되새겨보면서 프로그램 짜기
 - 컴파일러가 잡아주지 못하는 상수 오타
 - 스택 오버플로 :재귀 호출의 깊이가 깊어져서 프로그램이 강제종료되는 실수 -> 자동으로 힙에 메모리를 할당하는 STL 컨테이너 사용하거나, 전역변수를 사용하기
 - 다차원 배열 인덱스 순서 바꿔 쓰기
 - 잘못된 비교 함수 작성
 - 최소, 최대 예외 잘못 다루기
 - 연산자 우선순위 잘못 쓰기
    - 연산자를 쓸때, 순서가 헷갈리는 경우 괄호로 감싸주어준다
 - 너무 느린 입출력 방식 선택
 - 변수 초기화 문제

### 3.4 디버깅과 테스팅
 - 코드를 복잡하게 짜는것을 피하고, 디버거 없이 프로그램의 버그를 찾아내는 연습 하기.
 - 디버거 대신 다음의 이 세가지 단계들을 밟는다.
    - 작은 입력에 대해 제대로 실행되나 확인하기
    - 단정문 사용하기: 주어진 조건이 거짓일때 오류 내기
    - 계산 중간 결과 출력하기: 어디서 처음 문제가 발생하는지 범위 좁힐수 있다.
 - 테스트에 관하여:
    - 답안 제출 전에 예제입력으로 프로그램 테스트 많이하기
    - 스캐폴딩: 뼈대를 잡기위해 임시로 사용하는 코드. 스캐폴딩은 코드의 정당성 확인하거나 반례를 찾는데 유용하게 쓰인다.

### 3.5 변수 범위의 이해
 - 산술 오버플로 주의하기
 - 너무 큰 결과, 너무 큰 중간 값, 너무 큰 무한대 값 주의하기
 - 오버플로 피해가는 방법:
    - 더 큰 자료형 쓰기
    - 연산의 순서를 바꾸기
 - 자료형의 프로모션: 사칙연산등을 할때, 두개의 피연산자를 받을 경우, 이 둘을 같은 자료형으로 변환해서 계산하는것. 가끔 알기 어려운 버그를 만들게 된다.

### 3.6 실수 자료형의 이해
 - 실수 비교하기
    - 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
    - 상대 오차를 이용한다.
 - 대소 비교: 항상 두 값이 같은 경우, 두 값이 아주 가까운 경우를 먼저 확인하고 처리해 주어야 한다.
 - 실수 연산에서 오차를 없애는 법
    - 실수 연산을 아예 하지 않기:
    1. 곱셈과 나눗셈의 순서를 바꿔 실수 연산 쓰지않기.
    2. 좌표 두 점의 거리를 구할때, 루트를 쓰는 연산을 빼고, 양 변을 제곱하여 실수 연산 쓰지 않기.
    3. 실수 연산이 필요한 곳에서 좌표계의 가로 세로를 정수배 늘리면 정수만을 이용해 풀수도 있다.











